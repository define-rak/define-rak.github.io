<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Карта з зовнішнім GeoJSON (не вбудованим)</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
<style>
  html, body, #map { height: 100%; margin: 0; }
  .legend { background: white; padding: 8px 10px; border-radius: 4px; line-height: 1.2; font: 12px/1.2 sans-serif; }
  .legend .scale { height: 10px; width: 200px; background: linear-gradient(to right, #2ECC71, #F1C40F, #E74C3C); margin: 6px 0; }
</style>
</head>
<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script>
  var map = L.map('map').setView([50.45043695545825, 30.517925621759716], 12);
  L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
    maxZoom: 20
  }).addTo(map);

  function lerp(a, b, t) { return a + (b - a) * t; }
  function interpolateColor(t) {
    t = Math.max(0, Math.min(1, t));
    if (t <= 0.5) {
      var tt = t / 0.5;
      var r = Math.round(lerp(0x2E, 0xF1, tt));
      var g = Math.round(lerp(0xCC, 0xC4, tt));
      var b = Math.round(lerp(0x71, 0x0F, tt));
      return '#' + r.toString(16).padStart(2,'0') + g.toString(16).padStart(2,'0') + b.toString(16).padStart(2,'0');
    } else {
      var tt = (t - 0.5) / 0.5;
      var r = Math.round(lerp(0xF1, 0xE7, tt));
      var g = Math.round(lerp(0xC4, 0x4C, tt));
      var b = Math.round(lerp(0x0F, 0x3C, tt));
      return '#' + r.toString(16).padStart(2,'0') + g.toString(16).padStart(2,'0') + b.toString(16).padStart(2,'0');
    }
  }

  const url = 'kyiv_stop_shelters_20250903.geojson';

  fetch(url)
    .then(r => r.json())
    .then(data => {
      var distances = [];
      data.features.forEach(f => {
        var d = f.properties && f.properties.distance;
        if (d !== null && d !== undefined && d !== '' && d !== 'NULL') {
          var num = Number(d);
          if (!isNaN(num) && isFinite(num)) distances.push(num);
        }
      });

      var groups = {}, nullGroup = L.layerGroup([]), overlays = {};
      var dmin, dmax, bins = [];
      if (distances.length) {
        dmin = Math.min.apply(null, distances);
        dmax = Math.max.apply(null, distances);
        var dminBin = Math.floor(dmin / 50) * 50;
        var dmaxBin = Math.ceil(dmax / 50) * 50;
        for (var v = dminBin; v <= dmaxBin; v += 50) bins.push(v);

        for (var i = 0; i < bins.length-1; i++) {
          var left = bins[i], right = bins[i+1];
          var label = left + ' – ' + right;
          var lg = L.layerGroup([]);
          groups[label] = lg;
          overlays['distance: ' + label] = lg;
        }
      }

      data.features.forEach(f => {
        if (!f.geometry || f.geometry.type !== 'Point') return;
        var c = f.geometry.coordinates;
        if (!c || c.length < 2) return;
        var lon = c[0], lat = c[1];

        var raw = f.properties ? f.properties.distance : null;
        var dist = null;
        if (raw !== null && raw !== undefined && raw !== '' && raw !== 'NULL') {
          var n = Number(raw);
          if (!isNaN(n) && isFinite(n)) dist = n;
        }

        var name = null;
        var nameKeys = ['name','stop_name','stop','title','Назва','Назва_зупинки'];
        if (f.properties) {
          for (var k of nameKeys) { if (f.properties[k]) { name = f.properties[k]; break; } }
        }
        var popup = (name ? '<b>'+name+'</b><br/>' : '') + 'distance: ' + (dist===null?'NULL':dist);

        if (dist === null) {
          L.circleMarker([lat, lon], { radius:5, color:'#000', fillColor:'#000', fillOpacity:0.85, weight:1 })
            .bindPopup(popup).addTo(nullGroup);
        } else {
          var t = (dist - dmin) / (dmax - dmin || 1);
          var color = interpolateColor(t);

          var target = null;
          for (var i = 0; i < bins.length - 1; i++) {
            var left = bins[i], right = bins[i+1];
            if (dist >= left && dist < right) { target = groups[left + ' – ' + right]; break; }
          }
          if (!target) { target = groups[bins[bins.length-2] + ' – ' + bins[bins.length-1]]; }

          L.circleMarker([lat, lon], { radius:5, color:color, fillColor:color, fillOpacity:0.85, weight:1 })
            .bindPopup(popup).addTo(target);
        }
      });

      var layerControl = L.control.layers(null, overlays, { collapsed:false }).addTo(map);
      nullGroup.addTo(map);
      layerControl.addOverlay(nullGroup, 'Відсутній distance (чорні)');

      var legend = L.control({position:'bottomright'});
      legend.onAdd = function(map) {
        var div = L.DomUtil.create('div', 'legend');
        div.innerHTML = '<div><b>distance</b> (зелений → червоний)</div>' +
                        '<div class="scale"></div>' +
                        (bins.length ? '<div>'+bins[0]+' … '+bins[bins.length-1]+'</div>' : '');
        return div;
      };
      legend.addTo(map);
    })
    .catch(err => {
      console.error('Cannot load GeoJSON:', err);
      alert('Не вдалося завантажити GeoJSON. Перевірте шлях до файлу.');
    });
</script>
</body>
</html>
